// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: raftcmdpb.proto

package raftcmdpb

import (
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	errorpb "github.com/deepfabric/beehive/pb/errorpb"
	metapb "github.com/deepfabric/beehive/pb/metapb"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ChangePeerType add or remove node
type ChangePeerType int32

const (
	AddNode    ChangePeerType = 0
	RemoveNode ChangePeerType = 1
)

var ChangePeerType_name = map[int32]string{
	0: "AddNode",
	1: "RemoveNode",
}

var ChangePeerType_value = map[string]int32{
	"AddNode":    0,
	"RemoveNode": 1,
}

func (x ChangePeerType) String() string {
	return proto.EnumName(ChangePeerType_name, int32(x))
}

func (ChangePeerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c4d8ad5550754569, []int{0}
}

type CMDType int32

const (
	Invalid   CMDType = 0
	RaftError CMDType = 1
	Snap      CMDType = 2
	Write     CMDType = 3
	Read      CMDType = 4
)

var CMDType_name = map[int32]string{
	0: "Invalid",
	1: "RaftError",
	2: "Snap",
	3: "Write",
	4: "Read",
}

var CMDType_value = map[string]int32{
	"Invalid":   0,
	"RaftError": 1,
	"Snap":      2,
	"Write":     3,
	"Read":      4,
}

func (x CMDType) String() string {
	return proto.EnumName(CMDType_name, int32(x))
}

func (CMDType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c4d8ad5550754569, []int{1}
}

type AdminCmdType int32

const (
	InvalidAdmin   AdminCmdType = 0
	ChangePeer     AdminCmdType = 1
	Split          AdminCmdType = 2
	CompactRaftLog AdminCmdType = 3
	TransferLeader AdminCmdType = 4
	ComputeHash    AdminCmdType = 5
	VerifyHash     AdminCmdType = 6
)

var AdminCmdType_name = map[int32]string{
	0: "InvalidAdmin",
	1: "ChangePeer",
	2: "Split",
	3: "CompactRaftLog",
	4: "TransferLeader",
	5: "ComputeHash",
	6: "VerifyHash",
}

var AdminCmdType_value = map[string]int32{
	"InvalidAdmin":   0,
	"ChangePeer":     1,
	"Split":          2,
	"CompactRaftLog": 3,
	"TransferLeader": 4,
	"ComputeHash":    5,
	"VerifyHash":     6,
}

func (x AdminCmdType) String() string {
	return proto.EnumName(AdminCmdType_name, int32(x))
}

func (AdminCmdType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c4d8ad5550754569, []int{2}
}

// RaftRequestHeader raft request header, it contains the shard's metadata
type RaftRequestHeader struct {
	ID         []byte            `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	ShardID    uint64            `protobuf:"varint,2,opt,name=shardID,proto3" json:"shardID,omitempty"`
	Peer       metapb.Peer       `protobuf:"bytes,3,opt,name=peer,proto3" json:"peer"`
	ShardEpoch metapb.ShardEpoch `protobuf:"bytes,5,opt,name=shardEpoch,proto3" json:"shardEpoch"`
	Term       uint64            `protobuf:"varint,6,opt,name=term,proto3" json:"term,omitempty"`
}

func (m *RaftRequestHeader) Reset()         { *m = RaftRequestHeader{} }
func (m *RaftRequestHeader) String() string { return proto.CompactTextString(m) }
func (*RaftRequestHeader) ProtoMessage()    {}
func (*RaftRequestHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4d8ad5550754569, []int{0}
}
func (m *RaftRequestHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftRequestHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftRequestHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RaftRequestHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftRequestHeader.Merge(m, src)
}
func (m *RaftRequestHeader) XXX_Size() int {
	return m.Size()
}
func (m *RaftRequestHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftRequestHeader.DiscardUnknown(m)
}

var xxx_messageInfo_RaftRequestHeader proto.InternalMessageInfo

func (m *RaftRequestHeader) GetID() []byte {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *RaftRequestHeader) GetShardID() uint64 {
	if m != nil {
		return m.ShardID
	}
	return 0
}

func (m *RaftRequestHeader) GetPeer() metapb.Peer {
	if m != nil {
		return m.Peer
	}
	return metapb.Peer{}
}

func (m *RaftRequestHeader) GetShardEpoch() metapb.ShardEpoch {
	if m != nil {
		return m.ShardEpoch
	}
	return metapb.ShardEpoch{}
}

func (m *RaftRequestHeader) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

type RaftResponseHeader struct {
	ID          []byte        `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Error       errorpb.Error `protobuf:"bytes,2,opt,name=error,proto3" json:"error"`
	CurrentTerm uint64        `protobuf:"varint,3,opt,name=currentTerm,proto3" json:"currentTerm,omitempty"`
}

func (m *RaftResponseHeader) Reset()         { *m = RaftResponseHeader{} }
func (m *RaftResponseHeader) String() string { return proto.CompactTextString(m) }
func (*RaftResponseHeader) ProtoMessage()    {}
func (*RaftResponseHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4d8ad5550754569, []int{1}
}
func (m *RaftResponseHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftResponseHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftResponseHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RaftResponseHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftResponseHeader.Merge(m, src)
}
func (m *RaftResponseHeader) XXX_Size() int {
	return m.Size()
}
func (m *RaftResponseHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftResponseHeader.DiscardUnknown(m)
}

var xxx_messageInfo_RaftResponseHeader proto.InternalMessageInfo

func (m *RaftResponseHeader) GetID() []byte {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *RaftResponseHeader) GetError() errorpb.Error {
	if m != nil {
		return m.Error
	}
	return errorpb.Error{}
}

func (m *RaftResponseHeader) GetCurrentTerm() uint64 {
	if m != nil {
		return m.CurrentTerm
	}
	return 0
}

// RaftCMDRequest we can't include both normal requests and administrator request
// at same time.
type RaftCMDRequest struct {
	Header       *RaftRequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	Requests     []*Request         `protobuf:"bytes,2,rep,name=requests,proto3" json:"requests,omitempty"`
	AdminRequest *AdminRequest      `protobuf:"bytes,3,opt,name=adminRequest,proto3" json:"adminRequest,omitempty"`
}

func (m *RaftCMDRequest) Reset()         { *m = RaftCMDRequest{} }
func (m *RaftCMDRequest) String() string { return proto.CompactTextString(m) }
func (*RaftCMDRequest) ProtoMessage()    {}
func (*RaftCMDRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4d8ad5550754569, []int{2}
}
func (m *RaftCMDRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftCMDRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftCMDRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RaftCMDRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftCMDRequest.Merge(m, src)
}
func (m *RaftCMDRequest) XXX_Size() int {
	return m.Size()
}
func (m *RaftCMDRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftCMDRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RaftCMDRequest proto.InternalMessageInfo

func (m *RaftCMDRequest) GetHeader() *RaftRequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *RaftCMDRequest) GetRequests() []*Request {
	if m != nil {
		return m.Requests
	}
	return nil
}

func (m *RaftCMDRequest) GetAdminRequest() *AdminRequest {
	if m != nil {
		return m.AdminRequest
	}
	return nil
}

type RaftCMDResponse struct {
	Header        *RaftResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	Responses     []*Response         `protobuf:"bytes,2,rep,name=responses,proto3" json:"responses,omitempty"`
	AdminResponse *AdminResponse      `protobuf:"bytes,3,opt,name=adminResponse,proto3" json:"adminResponse,omitempty"`
}

func (m *RaftCMDResponse) Reset()         { *m = RaftCMDResponse{} }
func (m *RaftCMDResponse) String() string { return proto.CompactTextString(m) }
func (*RaftCMDResponse) ProtoMessage()    {}
func (*RaftCMDResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4d8ad5550754569, []int{3}
}
func (m *RaftCMDResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftCMDResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftCMDResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RaftCMDResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftCMDResponse.Merge(m, src)
}
func (m *RaftCMDResponse) XXX_Size() int {
	return m.Size()
}
func (m *RaftCMDResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftCMDResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RaftCMDResponse proto.InternalMessageInfo

func (m *RaftCMDResponse) GetHeader() *RaftResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *RaftCMDResponse) GetResponses() []*Response {
	if m != nil {
		return m.Responses
	}
	return nil
}

func (m *RaftCMDResponse) GetAdminResponse() *AdminResponse {
	if m != nil {
		return m.AdminResponse
	}
	return nil
}

// AdminRequest admin request
type AdminRequest struct {
	CmdType    AdminCmdType           `protobuf:"varint,1,opt,name=cmdType,proto3,enum=raftcmdpb.AdminCmdType" json:"cmdType,omitempty"`
	ChangePeer *ChangePeerRequest     `protobuf:"bytes,2,opt,name=changePeer,proto3" json:"changePeer,omitempty"`
	Split      *SplitRequest          `protobuf:"bytes,3,opt,name=split,proto3" json:"split,omitempty"`
	Transfer   *TransferLeaderRequest `protobuf:"bytes,4,opt,name=transfer,proto3" json:"transfer,omitempty"`
	Compact    *CompactRaftLogRequest `protobuf:"bytes,5,opt,name=compact,proto3" json:"compact,omitempty"`
}

func (m *AdminRequest) Reset()         { *m = AdminRequest{} }
func (m *AdminRequest) String() string { return proto.CompactTextString(m) }
func (*AdminRequest) ProtoMessage()    {}
func (*AdminRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4d8ad5550754569, []int{4}
}
func (m *AdminRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdminRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AdminRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AdminRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdminRequest.Merge(m, src)
}
func (m *AdminRequest) XXX_Size() int {
	return m.Size()
}
func (m *AdminRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AdminRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AdminRequest proto.InternalMessageInfo

func (m *AdminRequest) GetCmdType() AdminCmdType {
	if m != nil {
		return m.CmdType
	}
	return InvalidAdmin
}

func (m *AdminRequest) GetChangePeer() *ChangePeerRequest {
	if m != nil {
		return m.ChangePeer
	}
	return nil
}

func (m *AdminRequest) GetSplit() *SplitRequest {
	if m != nil {
		return m.Split
	}
	return nil
}

func (m *AdminRequest) GetTransfer() *TransferLeaderRequest {
	if m != nil {
		return m.Transfer
	}
	return nil
}

func (m *AdminRequest) GetCompact() *CompactRaftLogRequest {
	if m != nil {
		return m.Compact
	}
	return nil
}

// AdminResponse admin response
type AdminResponse struct {
	Type       AdminCmdType            `protobuf:"varint,1,opt,name=type,proto3,enum=raftcmdpb.AdminCmdType" json:"type,omitempty"`
	ChangePeer *ChangePeerResponse     `protobuf:"bytes,2,opt,name=changePeer,proto3" json:"changePeer,omitempty"`
	Split      *SplitResponse          `protobuf:"bytes,3,opt,name=split,proto3" json:"split,omitempty"`
	Transfer   *TransferLeaderResponse `protobuf:"bytes,4,opt,name=transfer,proto3" json:"transfer,omitempty"`
	Compact    *CompactRaftLogResponse `protobuf:"bytes,5,opt,name=compact,proto3" json:"compact,omitempty"`
}

func (m *AdminResponse) Reset()         { *m = AdminResponse{} }
func (m *AdminResponse) String() string { return proto.CompactTextString(m) }
func (*AdminResponse) ProtoMessage()    {}
func (*AdminResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4d8ad5550754569, []int{5}
}
func (m *AdminResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdminResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AdminResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AdminResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdminResponse.Merge(m, src)
}
func (m *AdminResponse) XXX_Size() int {
	return m.Size()
}
func (m *AdminResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AdminResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AdminResponse proto.InternalMessageInfo

func (m *AdminResponse) GetType() AdminCmdType {
	if m != nil {
		return m.Type
	}
	return InvalidAdmin
}

func (m *AdminResponse) GetChangePeer() *ChangePeerResponse {
	if m != nil {
		return m.ChangePeer
	}
	return nil
}

func (m *AdminResponse) GetSplit() *SplitResponse {
	if m != nil {
		return m.Split
	}
	return nil
}

func (m *AdminResponse) GetTransfer() *TransferLeaderResponse {
	if m != nil {
		return m.Transfer
	}
	return nil
}

func (m *AdminResponse) GetCompact() *CompactRaftLogResponse {
	if m != nil {
		return m.Compact
	}
	return nil
}

// ChangePeerRequest change peer request
type ChangePeerRequest struct {
	ChangeType ChangePeerType `protobuf:"varint,1,opt,name=changeType,proto3,enum=raftcmdpb.ChangePeerType" json:"changeType,omitempty"`
	Peer       metapb.Peer    `protobuf:"bytes,2,opt,name=peer,proto3" json:"peer"`
}

func (m *ChangePeerRequest) Reset()         { *m = ChangePeerRequest{} }
func (m *ChangePeerRequest) String() string { return proto.CompactTextString(m) }
func (*ChangePeerRequest) ProtoMessage()    {}
func (*ChangePeerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4d8ad5550754569, []int{6}
}
func (m *ChangePeerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangePeerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChangePeerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChangePeerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangePeerRequest.Merge(m, src)
}
func (m *ChangePeerRequest) XXX_Size() int {
	return m.Size()
}
func (m *ChangePeerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangePeerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ChangePeerRequest proto.InternalMessageInfo

func (m *ChangePeerRequest) GetChangeType() ChangePeerType {
	if m != nil {
		return m.ChangeType
	}
	return AddNode
}

func (m *ChangePeerRequest) GetPeer() metapb.Peer {
	if m != nil {
		return m.Peer
	}
	return metapb.Peer{}
}

// ChangePeerResponse change peer response
type ChangePeerResponse struct {
	Shard metapb.Shard `protobuf:"bytes,1,opt,name=shard,proto3" json:"shard"`
}

func (m *ChangePeerResponse) Reset()         { *m = ChangePeerResponse{} }
func (m *ChangePeerResponse) String() string { return proto.CompactTextString(m) }
func (*ChangePeerResponse) ProtoMessage()    {}
func (*ChangePeerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4d8ad5550754569, []int{7}
}
func (m *ChangePeerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangePeerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChangePeerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChangePeerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangePeerResponse.Merge(m, src)
}
func (m *ChangePeerResponse) XXX_Size() int {
	return m.Size()
}
func (m *ChangePeerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangePeerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ChangePeerResponse proto.InternalMessageInfo

func (m *ChangePeerResponse) GetShard() metapb.Shard {
	if m != nil {
		return m.Shard
	}
	return metapb.Shard{}
}

// SplitRequest split shard request
type SplitRequest struct {
	// This can be only called in internal RaftStore now.
	// The splitKey must be in the been splitting shard.
	SplitKey []byte `protobuf:"bytes,1,opt,name=splitKey,proto3" json:"splitKey,omitempty"`
	// We split the shard into two, first uses the shard
	// parent shard id, and the second uses the new_shard_id.
	// We must guarantee that the new_shard_id is global unique.
	NewShardID uint64 `protobuf:"varint,2,opt,name=newShardID,proto3" json:"newShardID,omitempty"`
	// The peer ids for the new split shard.
	NewPeerIDs []uint64 `protobuf:"varint,3,rep,packed,name=newPeerIDs,proto3" json:"newPeerIDs,omitempty"`
	// If true, right shard derive the origin shard_id,
	// left shard use new_shard_id.
	RightDerive bool `protobuf:"varint,4,opt,name=rightDerive,proto3" json:"rightDerive,omitempty"`
}

func (m *SplitRequest) Reset()         { *m = SplitRequest{} }
func (m *SplitRequest) String() string { return proto.CompactTextString(m) }
func (*SplitRequest) ProtoMessage()    {}
func (*SplitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4d8ad5550754569, []int{8}
}
func (m *SplitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SplitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SplitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SplitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SplitRequest.Merge(m, src)
}
func (m *SplitRequest) XXX_Size() int {
	return m.Size()
}
func (m *SplitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SplitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SplitRequest proto.InternalMessageInfo

func (m *SplitRequest) GetSplitKey() []byte {
	if m != nil {
		return m.SplitKey
	}
	return nil
}

func (m *SplitRequest) GetNewShardID() uint64 {
	if m != nil {
		return m.NewShardID
	}
	return 0
}

func (m *SplitRequest) GetNewPeerIDs() []uint64 {
	if m != nil {
		return m.NewPeerIDs
	}
	return nil
}

func (m *SplitRequest) GetRightDerive() bool {
	if m != nil {
		return m.RightDerive
	}
	return false
}

// SplitResponse split shard response
type SplitResponse struct {
	Left  metapb.Shard `protobuf:"bytes,1,opt,name=left,proto3" json:"left"`
	Right metapb.Shard `protobuf:"bytes,2,opt,name=right,proto3" json:"right"`
}

func (m *SplitResponse) Reset()         { *m = SplitResponse{} }
func (m *SplitResponse) String() string { return proto.CompactTextString(m) }
func (*SplitResponse) ProtoMessage()    {}
func (*SplitResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4d8ad5550754569, []int{9}
}
func (m *SplitResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SplitResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SplitResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SplitResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SplitResponse.Merge(m, src)
}
func (m *SplitResponse) XXX_Size() int {
	return m.Size()
}
func (m *SplitResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SplitResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SplitResponse proto.InternalMessageInfo

func (m *SplitResponse) GetLeft() metapb.Shard {
	if m != nil {
		return m.Left
	}
	return metapb.Shard{}
}

func (m *SplitResponse) GetRight() metapb.Shard {
	if m != nil {
		return m.Right
	}
	return metapb.Shard{}
}

// TransferLeaderRequest transfer leader request
type TransferLeaderRequest struct {
	Peer metapb.Peer `protobuf:"bytes,1,opt,name=peer,proto3" json:"peer"`
}

func (m *TransferLeaderRequest) Reset()         { *m = TransferLeaderRequest{} }
func (m *TransferLeaderRequest) String() string { return proto.CompactTextString(m) }
func (*TransferLeaderRequest) ProtoMessage()    {}
func (*TransferLeaderRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4d8ad5550754569, []int{10}
}
func (m *TransferLeaderRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransferLeaderRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransferLeaderRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransferLeaderRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransferLeaderRequest.Merge(m, src)
}
func (m *TransferLeaderRequest) XXX_Size() int {
	return m.Size()
}
func (m *TransferLeaderRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TransferLeaderRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TransferLeaderRequest proto.InternalMessageInfo

func (m *TransferLeaderRequest) GetPeer() metapb.Peer {
	if m != nil {
		return m.Peer
	}
	return metapb.Peer{}
}

// TransferLeaderResponse transfer leader response
type TransferLeaderResponse struct {
}

func (m *TransferLeaderResponse) Reset()         { *m = TransferLeaderResponse{} }
func (m *TransferLeaderResponse) String() string { return proto.CompactTextString(m) }
func (*TransferLeaderResponse) ProtoMessage()    {}
func (*TransferLeaderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4d8ad5550754569, []int{11}
}
func (m *TransferLeaderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransferLeaderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransferLeaderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransferLeaderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransferLeaderResponse.Merge(m, src)
}
func (m *TransferLeaderResponse) XXX_Size() int {
	return m.Size()
}
func (m *TransferLeaderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TransferLeaderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TransferLeaderResponse proto.InternalMessageInfo

// CompactRaftLogRequest compact raft log request
type CompactRaftLogRequest struct {
	CompactIndex uint64 `protobuf:"varint,1,opt,name=compactIndex,proto3" json:"compactIndex,omitempty"`
	CompactTerm  uint64 `protobuf:"varint,2,opt,name=compactTerm,proto3" json:"compactTerm,omitempty"`
}

func (m *CompactRaftLogRequest) Reset()         { *m = CompactRaftLogRequest{} }
func (m *CompactRaftLogRequest) String() string { return proto.CompactTextString(m) }
func (*CompactRaftLogRequest) ProtoMessage()    {}
func (*CompactRaftLogRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4d8ad5550754569, []int{12}
}
func (m *CompactRaftLogRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompactRaftLogRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompactRaftLogRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CompactRaftLogRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompactRaftLogRequest.Merge(m, src)
}
func (m *CompactRaftLogRequest) XXX_Size() int {
	return m.Size()
}
func (m *CompactRaftLogRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CompactRaftLogRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CompactRaftLogRequest proto.InternalMessageInfo

func (m *CompactRaftLogRequest) GetCompactIndex() uint64 {
	if m != nil {
		return m.CompactIndex
	}
	return 0
}

func (m *CompactRaftLogRequest) GetCompactTerm() uint64 {
	if m != nil {
		return m.CompactTerm
	}
	return 0
}

// CompactRaftLogResponse compact raft log response
type CompactRaftLogResponse struct {
}

func (m *CompactRaftLogResponse) Reset()         { *m = CompactRaftLogResponse{} }
func (m *CompactRaftLogResponse) String() string { return proto.CompactTextString(m) }
func (*CompactRaftLogResponse) ProtoMessage()    {}
func (*CompactRaftLogResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4d8ad5550754569, []int{13}
}
func (m *CompactRaftLogResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompactRaftLogResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompactRaftLogResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CompactRaftLogResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompactRaftLogResponse.Merge(m, src)
}
func (m *CompactRaftLogResponse) XXX_Size() int {
	return m.Size()
}
func (m *CompactRaftLogResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CompactRaftLogResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CompactRaftLogResponse proto.InternalMessageInfo

// Request request
type Request struct {
	ID            []byte  `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Group         uint64  `protobuf:"varint,2,opt,name=group,proto3" json:"group,omitempty"`
	Type          CMDType `protobuf:"varint,3,opt,name=type,proto3,enum=raftcmdpb.CMDType" json:"type,omitempty"`
	CustemType    uint64  `protobuf:"varint,4,opt,name=custemType,proto3" json:"custemType,omitempty"`
	Key           []byte  `protobuf:"bytes,5,opt,name=key,proto3" json:"key,omitempty"`
	Cmd           []byte  `protobuf:"bytes,6,opt,name=cmd,proto3" json:"cmd,omitempty"`
	SID           int64   `protobuf:"varint,7,opt,name=sid,proto3" json:"sid,omitempty"`
	PID           int64   `protobuf:"varint,8,opt,name=pid,proto3" json:"pid,omitempty"`
	StopAt        int64   `protobuf:"varint,9,opt,name=stopAt,proto3" json:"stopAt,omitempty"`
	ToShard       uint64  `protobuf:"varint,10,opt,name=toShard,proto3" json:"toShard,omitempty"`
	AllowFollower bool    `protobuf:"varint,11,opt,name=allowFollower,proto3" json:"allowFollower,omitempty"`
	LastBroadcast bool    `protobuf:"varint,12,opt,name=lastBroadcast,proto3" json:"lastBroadcast,omitempty"`
}

func (m *Request) Reset()         { *m = Request{} }
func (m *Request) String() string { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()    {}
func (*Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4d8ad5550754569, []int{14}
}
func (m *Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request.Merge(m, src)
}
func (m *Request) XXX_Size() int {
	return m.Size()
}
func (m *Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Request.DiscardUnknown(m)
}

var xxx_messageInfo_Request proto.InternalMessageInfo

func (m *Request) GetID() []byte {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *Request) GetGroup() uint64 {
	if m != nil {
		return m.Group
	}
	return 0
}

func (m *Request) GetType() CMDType {
	if m != nil {
		return m.Type
	}
	return Invalid
}

func (m *Request) GetCustemType() uint64 {
	if m != nil {
		return m.CustemType
	}
	return 0
}

func (m *Request) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Request) GetCmd() []byte {
	if m != nil {
		return m.Cmd
	}
	return nil
}

func (m *Request) GetSID() int64 {
	if m != nil {
		return m.SID
	}
	return 0
}

func (m *Request) GetPID() int64 {
	if m != nil {
		return m.PID
	}
	return 0
}

func (m *Request) GetStopAt() int64 {
	if m != nil {
		return m.StopAt
	}
	return 0
}

func (m *Request) GetToShard() uint64 {
	if m != nil {
		return m.ToShard
	}
	return 0
}

func (m *Request) GetAllowFollower() bool {
	if m != nil {
		return m.AllowFollower
	}
	return false
}

func (m *Request) GetLastBroadcast() bool {
	if m != nil {
		return m.LastBroadcast
	}
	return false
}

// Response response
type Response struct {
	ID                []byte        `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Type              CMDType       `protobuf:"varint,2,opt,name=type,proto3,enum=raftcmdpb.CMDType" json:"type,omitempty"`
	Value             []byte        `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	OriginRequest     *Request      `protobuf:"bytes,4,opt,name=originRequest,proto3" json:"originRequest,omitempty"`
	SID               int64         `protobuf:"varint,5,opt,name=sid,proto3" json:"sid,omitempty"`
	PID               int64         `protobuf:"varint,6,opt,name=pid,proto3" json:"pid,omitempty"`
	Error             errorpb.Error `protobuf:"bytes,7,opt,name=error,proto3" json:"error"`
	ContinueBroadcast bool          `protobuf:"varint,8,opt,name=continueBroadcast,proto3" json:"continueBroadcast,omitempty"`
	Stale             bool          `protobuf:"varint,9,opt,name=stale,proto3" json:"stale,omitempty"`
}

func (m *Response) Reset()         { *m = Response{} }
func (m *Response) String() string { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()    {}
func (*Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4d8ad5550754569, []int{15}
}
func (m *Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response.Merge(m, src)
}
func (m *Response) XXX_Size() int {
	return m.Size()
}
func (m *Response) XXX_DiscardUnknown() {
	xxx_messageInfo_Response.DiscardUnknown(m)
}

var xxx_messageInfo_Response proto.InternalMessageInfo

func (m *Response) GetID() []byte {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *Response) GetType() CMDType {
	if m != nil {
		return m.Type
	}
	return Invalid
}

func (m *Response) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Response) GetOriginRequest() *Request {
	if m != nil {
		return m.OriginRequest
	}
	return nil
}

func (m *Response) GetSID() int64 {
	if m != nil {
		return m.SID
	}
	return 0
}

func (m *Response) GetPID() int64 {
	if m != nil {
		return m.PID
	}
	return 0
}

func (m *Response) GetError() errorpb.Error {
	if m != nil {
		return m.Error
	}
	return errorpb.Error{}
}

func (m *Response) GetContinueBroadcast() bool {
	if m != nil {
		return m.ContinueBroadcast
	}
	return false
}

func (m *Response) GetStale() bool {
	if m != nil {
		return m.Stale
	}
	return false
}

func init() {
	proto.RegisterEnum("raftcmdpb.ChangePeerType", ChangePeerType_name, ChangePeerType_value)
	proto.RegisterEnum("raftcmdpb.CMDType", CMDType_name, CMDType_value)
	proto.RegisterEnum("raftcmdpb.AdminCmdType", AdminCmdType_name, AdminCmdType_value)
	proto.RegisterType((*RaftRequestHeader)(nil), "raftcmdpb.RaftRequestHeader")
	proto.RegisterType((*RaftResponseHeader)(nil), "raftcmdpb.RaftResponseHeader")
	proto.RegisterType((*RaftCMDRequest)(nil), "raftcmdpb.RaftCMDRequest")
	proto.RegisterType((*RaftCMDResponse)(nil), "raftcmdpb.RaftCMDResponse")
	proto.RegisterType((*AdminRequest)(nil), "raftcmdpb.AdminRequest")
	proto.RegisterType((*AdminResponse)(nil), "raftcmdpb.AdminResponse")
	proto.RegisterType((*ChangePeerRequest)(nil), "raftcmdpb.ChangePeerRequest")
	proto.RegisterType((*ChangePeerResponse)(nil), "raftcmdpb.ChangePeerResponse")
	proto.RegisterType((*SplitRequest)(nil), "raftcmdpb.SplitRequest")
	proto.RegisterType((*SplitResponse)(nil), "raftcmdpb.SplitResponse")
	proto.RegisterType((*TransferLeaderRequest)(nil), "raftcmdpb.TransferLeaderRequest")
	proto.RegisterType((*TransferLeaderResponse)(nil), "raftcmdpb.TransferLeaderResponse")
	proto.RegisterType((*CompactRaftLogRequest)(nil), "raftcmdpb.CompactRaftLogRequest")
	proto.RegisterType((*CompactRaftLogResponse)(nil), "raftcmdpb.CompactRaftLogResponse")
	proto.RegisterType((*Request)(nil), "raftcmdpb.Request")
	proto.RegisterType((*Response)(nil), "raftcmdpb.Response")
}

func init() { proto.RegisterFile("raftcmdpb.proto", fileDescriptor_c4d8ad5550754569) }

var fileDescriptor_c4d8ad5550754569 = []byte{
	// 1212 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x56, 0x4b, 0x73, 0xdb, 0xd4,
	0x17, 0xb7, 0x1e, 0x7e, 0xe4, 0xf8, 0x11, 0xe5, 0xfe, 0xdb, 0xfc, 0xd5, 0x4c, 0xeb, 0xb8, 0x1a,
	0x06, 0x42, 0x20, 0xce, 0x10, 0x32, 0xbc, 0xda, 0xd2, 0x49, 0xe2, 0x32, 0xf5, 0xd0, 0x32, 0x1d,
	0x25, 0x03, 0x2b, 0x16, 0xb2, 0x74, 0x6d, 0x6b, 0xb0, 0x2d, 0x71, 0x25, 0xbb, 0x84, 0x35, 0x4b,
	0x16, 0x7c, 0x0b, 0xf8, 0x0e, 0x2c, 0xd8, 0x31, 0xdd, 0x30, 0x93, 0x1d, 0xac, 0x32, 0x90, 0x7c,
	0x11, 0xe6, 0x9e, 0x7b, 0x25, 0x4b, 0xb5, 0x93, 0xb0, 0xb1, 0x75, 0xce, 0xf9, 0xfd, 0xee, 0xb9,
	0xe7, 0x77, 0xcf, 0x7d, 0xc0, 0x2a, 0x73, 0xfa, 0xb1, 0x3b, 0xf6, 0xc2, 0x5e, 0x3b, 0x64, 0x41,
	0x1c, 0x90, 0x95, 0xd4, 0xb1, 0xb1, 0x3f, 0xf0, 0xe3, 0xe1, 0xb4, 0xd7, 0x76, 0x83, 0xf1, 0xae,
	0x47, 0x69, 0xd8, 0x77, 0x7a, 0xcc, 0x77, 0x77, 0x7b, 0x94, 0x0e, 0xfd, 0x19, 0xdd, 0x0d, 0x7b,
	0xbb, 0x63, 0x1a, 0x3b, 0xe9, 0x9f, 0x18, 0x60, 0xe3, 0x83, 0x1b, 0x59, 0x94, 0xb1, 0x80, 0xcd,
	0xff, 0x25, 0x6f, 0x27, 0xc3, 0x1b, 0x04, 0x83, 0x60, 0x17, 0xdd, 0xbd, 0x69, 0x1f, 0x2d, 0x34,
	0xf0, 0x4b, 0xc0, 0xad, 0x5f, 0x15, 0x58, 0xb3, 0x9d, 0x7e, 0x6c, 0xd3, 0x6f, 0xa7, 0x34, 0x8a,
	0x9f, 0x52, 0xc7, 0xa3, 0x8c, 0xac, 0x83, 0xea, 0x7b, 0xa6, 0xd2, 0x52, 0xb6, 0x6a, 0x87, 0xa5,
	0x8b, 0xf3, 0x4d, 0xb5, 0xdb, 0xb1, 0x55, 0xdf, 0x23, 0x26, 0x94, 0xa3, 0xa1, 0xc3, 0xbc, 0x6e,
	0xc7, 0x54, 0x5b, 0xca, 0x96, 0x6e, 0x27, 0x26, 0x79, 0x13, 0xf4, 0x90, 0x52, 0x66, 0x6a, 0x2d,
	0x65, 0xab, 0xba, 0x57, 0x6b, 0xcb, 0x5a, 0x5e, 0x50, 0xca, 0x0e, 0xf5, 0x57, 0xe7, 0x9b, 0x05,
	0x1b, 0xe3, 0xe4, 0x23, 0x00, 0xa4, 0x3c, 0x09, 0x03, 0x77, 0x68, 0x16, 0x11, 0x4d, 0x12, 0xf4,
	0x71, 0x1a, 0x91, 0x9c, 0x0c, 0x96, 0x10, 0xd0, 0x63, 0xca, 0xc6, 0x66, 0x09, 0x13, 0xe3, 0xb7,
	0xf5, 0x3d, 0x10, 0x31, 0xf9, 0x28, 0x0c, 0x26, 0x11, 0xbd, 0x61, 0xf6, 0xdb, 0x50, 0x44, 0xad,
	0x70, 0xee, 0xd5, 0xbd, 0x46, 0x3b, 0x51, 0xee, 0x09, 0xff, 0x97, 0x29, 0x05, 0x84, 0xb4, 0xa0,
	0xea, 0x4e, 0x19, 0xa3, 0x93, 0xf8, 0x84, 0x27, 0xd5, 0x30, 0x69, 0xd6, 0x65, 0xfd, 0xa6, 0x40,
	0x83, 0x27, 0x3f, 0x7a, 0xde, 0x91, 0xe2, 0x91, 0x7d, 0x28, 0x0d, 0x71, 0x0a, 0x98, 0xbc, 0xba,
	0x77, 0xb7, 0x3d, 0x6f, 0x8b, 0x05, 0x91, 0x6d, 0x89, 0x25, 0xfb, 0x50, 0x61, 0x22, 0x10, 0x99,
	0x6a, 0x4b, 0x43, 0x41, 0x32, 0x3c, 0x11, 0xc2, 0xd9, 0x29, 0x76, 0x8a, 0x24, 0x07, 0x50, 0x73,
	0xbc, 0xb1, 0x3f, 0x91, 0x71, 0x29, 0xfc, 0xff, 0x33, 0xcc, 0x83, 0x4c, 0x58, 0xd2, 0x73, 0x14,
	0xeb, 0x0f, 0x05, 0x56, 0xd3, 0x0a, 0x84, 0x82, 0xe4, 0xc1, 0x6b, 0x25, 0xdc, 0x5b, 0x28, 0x21,
	0x2b, 0xb5, 0x1c, 0x36, 0xa9, 0xe4, 0x43, 0x58, 0x61, 0x32, 0x9e, 0x94, 0xf2, 0xbf, 0x5c, 0x29,
	0x22, 0x26, 0x59, 0x73, 0x2c, 0xe9, 0x40, 0x5d, 0xce, 0x4c, 0x78, 0x64, 0x35, 0xe6, 0x62, 0x35,
	0xb9, 0x11, 0xf2, 0x24, 0xeb, 0x17, 0x15, 0x6a, 0xd9, 0xa2, 0xc9, 0x7b, 0x50, 0x76, 0xc7, 0xde,
	0xc9, 0x69, 0x48, 0xb1, 0x9a, 0xc6, 0xa2, 0x3c, 0x47, 0x22, 0x6c, 0x27, 0x38, 0xf2, 0x10, 0xc0,
	0x1d, 0x3a, 0x93, 0x01, 0xe5, 0x9d, 0x2b, 0x1b, 0x25, 0xbb, 0x8c, 0x47, 0x69, 0x50, 0x26, 0xb1,
	0x33, 0x78, 0xb2, 0x03, 0xc5, 0x28, 0x1c, 0xf9, 0xcb, 0x56, 0xe3, 0x98, 0xfb, 0x13, 0x8e, 0x40,
	0x91, 0x87, 0x50, 0x89, 0x99, 0x33, 0x89, 0xfa, 0x94, 0x99, 0x3a, 0x32, 0x5a, 0x19, 0xc6, 0x89,
	0x0c, 0x3d, 0x13, 0xed, 0x22, 0xa9, 0x29, 0x83, 0x7c, 0x02, 0x65, 0x37, 0x18, 0x87, 0x8e, 0x1b,
	0xcb, 0x7d, 0x94, 0x25, 0x1f, 0x89, 0x08, 0x5f, 0xb2, 0x67, 0xc1, 0x20, 0x21, 0x27, 0x04, 0xeb,
	0x67, 0x15, 0xea, 0x39, 0x45, 0xc9, 0x3b, 0xa0, 0xc7, 0xff, 0x41, 0x28, 0x04, 0x91, 0x47, 0x4b,
	0x54, 0xba, 0x77, 0x85, 0x4a, 0x62, 0xfc, 0x9c, 0x4c, 0xed, 0xbc, 0x4c, 0xe6, 0xa2, 0x4c, 0x92,
	0x24, 0x75, 0x7a, 0xb4, 0xa0, 0xd3, 0xfd, 0x6b, 0x74, 0x92, 0xdc, 0xb9, 0x50, 0x0f, 0x5e, 0x17,
	0xea, 0xfe, 0x35, 0x42, 0x49, 0x76, 0xaa, 0xd4, 0x0c, 0xd6, 0x16, 0xd6, 0x9c, 0x7c, 0x9c, 0xd4,
	0x9f, 0xe9, 0xad, 0x3b, 0x4b, 0xeb, 0x47, 0xd1, 0x32, 0xe0, 0xf4, 0xa0, 0x54, 0xaf, 0x3f, 0x28,
	0xad, 0xc7, 0x40, 0x16, 0x55, 0x24, 0x6f, 0x43, 0x11, 0x8f, 0x44, 0xb9, 0x3b, 0xeb, 0xb9, 0x93,
	0x33, 0x39, 0xc1, 0x10, 0x61, 0xfd, 0xa8, 0x40, 0x2d, 0xdb, 0x74, 0x64, 0x03, 0x2a, 0x28, 0xe7,
	0xe7, 0xf4, 0x54, 0x1c, 0x8e, 0x76, 0x6a, 0x93, 0x26, 0xc0, 0x84, 0xbe, 0x3c, 0xce, 0x9d, 0xed,
	0x19, 0x8f, 0x8c, 0xf3, 0xa9, 0x74, 0x3b, 0x91, 0xa9, 0xb5, 0x34, 0x19, 0x97, 0x1e, 0x7e, 0x5c,
	0x32, 0x7f, 0x30, 0x8c, 0x3b, 0x94, 0xf9, 0x33, 0x8a, 0x8b, 0x54, 0xb1, 0xb3, 0x2e, 0xcb, 0x85,
	0x7a, 0x6e, 0x6d, 0xc9, 0x5b, 0xa0, 0x8f, 0x68, 0x3f, 0xbe, 0xae, 0x12, 0x04, 0xf0, 0x9a, 0x71,
	0x20, 0x29, 0xd9, 0xf2, 0x9a, 0x11, 0x61, 0x3d, 0x86, 0xdb, 0x4b, 0x77, 0x4d, 0xaa, 0xba, 0x72,
	0x83, 0xea, 0x26, 0xac, 0x2f, 0x6f, 0x27, 0xeb, 0x6b, 0xb8, 0xbd, 0x74, 0x4f, 0x11, 0x0b, 0x6a,
	0xb2, 0x57, 0xba, 0x13, 0x8f, 0x7e, 0x87, 0x29, 0x74, 0x3b, 0xe7, 0xc3, 0xdb, 0x44, 0xd8, 0x78,
	0x9b, 0xa8, 0xf2, 0x36, 0x99, 0xbb, 0x78, 0xe2, 0xe5, 0x9d, 0x68, 0xfd, 0xa9, 0x42, 0x39, 0xc9,
	0x75, 0xd5, 0xcd, 0x76, 0x0b, 0x8a, 0x03, 0x16, 0x4c, 0x43, 0x39, 0xb2, 0x30, 0x78, 0xd1, 0xb8,
	0xa5, 0x35, 0xec, 0xcf, 0xec, 0xa5, 0x72, 0xf4, 0xbc, 0x93, 0xd9, 0xcd, 0x4d, 0x00, 0x77, 0x1a,
	0xc5, 0x74, 0x8c, 0xdd, 0xac, 0x8b, 0xc5, 0x9f, 0x7b, 0x88, 0x01, 0xda, 0x37, 0xf4, 0x14, 0xf7,
	0x4e, 0xcd, 0xe6, 0x9f, 0xdc, 0xe3, 0x8e, 0x3d, 0xbc, 0x8a, 0x6b, 0x36, 0xff, 0x24, 0x77, 0x40,
	0x8b, 0x7c, 0xcf, 0x2c, 0xb7, 0x94, 0x2d, 0xed, 0xb0, 0x7c, 0x71, 0xbe, 0xa9, 0x1d, 0x77, 0x3b,
	0x36, 0xf7, 0xf1, 0x50, 0xe8, 0x7b, 0x66, 0x65, 0x1e, 0x7a, 0xc1, 0x43, 0xa1, 0xef, 0x91, 0x75,
	0x28, 0x45, 0x71, 0x10, 0x1e, 0xc4, 0xe6, 0x0a, 0x8f, 0xda, 0xd2, 0xe2, 0xef, 0x8c, 0x38, 0xc0,
	0xf5, 0x35, 0x41, 0xbc, 0x33, 0xa4, 0x49, 0xde, 0x80, 0xba, 0x33, 0x1a, 0x05, 0x2f, 0x3f, 0x0b,
	0xf8, 0x2f, 0x65, 0x66, 0x15, 0x5b, 0x2d, 0xef, 0xe4, 0xa8, 0x91, 0x13, 0xc5, 0x87, 0x2c, 0x70,
	0x3c, 0xd7, 0x89, 0x62, 0xb3, 0x26, 0x50, 0x39, 0xa7, 0xf5, 0xbb, 0x0a, 0x95, 0xb4, 0x1d, 0xaf,
	0x92, 0x36, 0x11, 0x51, 0xbd, 0x41, 0xc4, 0x5b, 0x50, 0x9c, 0x39, 0xa3, 0xa9, 0x50, 0xbb, 0x66,
	0x0b, 0x83, 0x7c, 0x0a, 0xf5, 0x80, 0xf9, 0x83, 0xf9, 0x35, 0xad, 0xcb, 0x17, 0xcf, 0x55, 0x17,
	0x7c, 0x1e, 0x9e, 0xc8, 0x5a, 0xbc, 0x5a, 0xd6, 0xd2, 0x12, 0x59, 0xd3, 0x87, 0x4e, 0xf9, 0xe6,
	0x87, 0xce, 0xbb, 0xb0, 0xe6, 0x06, 0x93, 0xd8, 0x9f, 0x4c, 0xe9, 0x5c, 0xae, 0x0a, 0xca, 0xb5,
	0x18, 0xe0, 0x55, 0x46, 0xb1, 0x33, 0xa2, 0xb8, 0x5e, 0x15, 0x5b, 0x18, 0xdb, 0x3b, 0xd0, 0xc8,
	0x9f, 0x78, 0xa4, 0x0a, 0xe5, 0x03, 0xcf, 0xfb, 0x22, 0xf0, 0xa8, 0x51, 0x20, 0x0d, 0x00, 0x9b,
	0x8e, 0x83, 0x19, 0x45, 0x5b, 0xd9, 0xee, 0x40, 0x59, 0x6a, 0xc7, 0x71, 0xdd, 0xc9, 0xcc, 0x19,
	0xf9, 0x9e, 0x51, 0x20, 0x75, 0x58, 0xe1, 0xcd, 0x8f, 0x93, 0x34, 0x14, 0x52, 0x01, 0xfd, 0x78,
	0xe2, 0x84, 0x86, 0x4a, 0x56, 0xa0, 0xf8, 0x15, 0xf3, 0x63, 0x6a, 0x68, 0xdc, 0x69, 0x53, 0xc7,
	0x33, 0xf4, 0xed, 0x1f, 0x14, 0x79, 0xdb, 0xcb, 0xab, 0x89, 0x18, 0x50, 0x93, 0x63, 0xa1, 0x5b,
	0x24, 0x9e, 0xcf, 0xcb, 0x50, 0xf8, 0x38, 0x78, 0x06, 0x19, 0x2a, 0x21, 0xd0, 0xc8, 0xef, 0x37,
	0x43, 0xe3, 0xbe, 0xfc, 0xe6, 0x37, 0x74, 0xb2, 0x0a, 0x55, 0x8e, 0x9b, 0xc6, 0xf4, 0xa9, 0x13,
	0x0d, 0x8d, 0x22, 0x1f, 0xf3, 0x4b, 0xca, 0xfc, 0xfe, 0x29, 0xda, 0xa5, 0xc3, 0xbb, 0x67, 0xff,
	0x34, 0x0b, 0xaf, 0x2e, 0x9a, 0xca, 0xd9, 0x45, 0x53, 0xf9, 0xfb, 0xa2, 0xa9, 0xfc, 0x74, 0xd9,
	0x2c, 0x9c, 0x5d, 0x36, 0x0b, 0x7f, 0x5d, 0x36, 0x0b, 0xbd, 0x12, 0xbe, 0xb2, 0xdf, 0xff, 0x37,
	0x00, 0x00, 0xff, 0xff, 0xf2, 0x4c, 0xd1, 0xc3, 0x20, 0x0c, 0x00, 0x00,
}

func (m *RaftRequestHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftRequestHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftRequestHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Term != 0 {
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x30
	}
	{
		size, err := m.ShardEpoch.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Peer.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.ShardID != 0 {
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(m.ShardID))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RaftResponseHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftResponseHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftResponseHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CurrentTerm != 0 {
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(m.CurrentTerm))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RaftCMDRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftCMDRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftCMDRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AdminRequest != nil {
		{
			size, err := m.AdminRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Requests) > 0 {
		for iNdEx := len(m.Requests) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Requests[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RaftCMDResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftCMDResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftCMDResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AdminResponse != nil {
		{
			size, err := m.AdminResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Responses) > 0 {
		for iNdEx := len(m.Responses) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Responses[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AdminRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdminRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdminRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Compact != nil {
		{
			size, err := m.Compact.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Transfer != nil {
		{
			size, err := m.Transfer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Split != nil {
		{
			size, err := m.Split.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ChangePeer != nil {
		{
			size, err := m.ChangePeer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.CmdType != 0 {
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(m.CmdType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AdminResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdminResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdminResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Compact != nil {
		{
			size, err := m.Compact.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Transfer != nil {
		{
			size, err := m.Transfer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Split != nil {
		{
			size, err := m.Split.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ChangePeer != nil {
		{
			size, err := m.ChangePeer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ChangePeerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangePeerRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChangePeerRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Peer.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.ChangeType != 0 {
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(m.ChangeType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ChangePeerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangePeerResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChangePeerResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Shard.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SplitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SplitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SplitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RightDerive {
		i--
		if m.RightDerive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.NewPeerIDs) > 0 {
		dAtA19 := make([]byte, len(m.NewPeerIDs)*10)
		var j18 int
		for _, num := range m.NewPeerIDs {
			for num >= 1<<7 {
				dAtA19[j18] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j18++
			}
			dAtA19[j18] = uint8(num)
			j18++
		}
		i -= j18
		copy(dAtA[i:], dAtA19[:j18])
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(j18))
		i--
		dAtA[i] = 0x1a
	}
	if m.NewShardID != 0 {
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(m.NewShardID))
		i--
		dAtA[i] = 0x10
	}
	if len(m.SplitKey) > 0 {
		i -= len(m.SplitKey)
		copy(dAtA[i:], m.SplitKey)
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(len(m.SplitKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SplitResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SplitResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SplitResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Right.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Left.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TransferLeaderRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransferLeaderRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransferLeaderRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Peer.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TransferLeaderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransferLeaderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransferLeaderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *CompactRaftLogRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompactRaftLogRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompactRaftLogRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CompactTerm != 0 {
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(m.CompactTerm))
		i--
		dAtA[i] = 0x10
	}
	if m.CompactIndex != 0 {
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(m.CompactIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CompactRaftLogResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompactRaftLogResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompactRaftLogResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastBroadcast {
		i--
		if m.LastBroadcast {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.AllowFollower {
		i--
		if m.AllowFollower {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.ToShard != 0 {
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(m.ToShard))
		i--
		dAtA[i] = 0x50
	}
	if m.StopAt != 0 {
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(m.StopAt))
		i--
		dAtA[i] = 0x48
	}
	if m.PID != 0 {
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(m.PID))
		i--
		dAtA[i] = 0x40
	}
	if m.SID != 0 {
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(m.SID))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Cmd) > 0 {
		i -= len(m.Cmd)
		copy(dAtA[i:], m.Cmd)
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(len(m.Cmd)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x2a
	}
	if m.CustemType != 0 {
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(m.CustemType))
		i--
		dAtA[i] = 0x20
	}
	if m.Type != 0 {
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if m.Group != 0 {
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(m.Group))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Stale {
		i--
		if m.Stale {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.ContinueBroadcast {
		i--
		if m.ContinueBroadcast {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	{
		size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if m.PID != 0 {
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(m.PID))
		i--
		dAtA[i] = 0x30
	}
	if m.SID != 0 {
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(m.SID))
		i--
		dAtA[i] = 0x28
	}
	if m.OriginRequest != nil {
		{
			size, err := m.OriginRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintRaftcmdpb(dAtA []byte, offset int, v uint64) int {
	offset -= sovRaftcmdpb(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *RaftRequestHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	if m.ShardID != 0 {
		n += 1 + sovRaftcmdpb(uint64(m.ShardID))
	}
	l = m.Peer.Size()
	n += 1 + l + sovRaftcmdpb(uint64(l))
	l = m.ShardEpoch.Size()
	n += 1 + l + sovRaftcmdpb(uint64(l))
	if m.Term != 0 {
		n += 1 + sovRaftcmdpb(uint64(m.Term))
	}
	return n
}

func (m *RaftResponseHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	l = m.Error.Size()
	n += 1 + l + sovRaftcmdpb(uint64(l))
	if m.CurrentTerm != 0 {
		n += 1 + sovRaftcmdpb(uint64(m.CurrentTerm))
	}
	return n
}

func (m *RaftCMDRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	if len(m.Requests) > 0 {
		for _, e := range m.Requests {
			l = e.Size()
			n += 1 + l + sovRaftcmdpb(uint64(l))
		}
	}
	if m.AdminRequest != nil {
		l = m.AdminRequest.Size()
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	return n
}

func (m *RaftCMDResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	if len(m.Responses) > 0 {
		for _, e := range m.Responses {
			l = e.Size()
			n += 1 + l + sovRaftcmdpb(uint64(l))
		}
	}
	if m.AdminResponse != nil {
		l = m.AdminResponse.Size()
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	return n
}

func (m *AdminRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdType != 0 {
		n += 1 + sovRaftcmdpb(uint64(m.CmdType))
	}
	if m.ChangePeer != nil {
		l = m.ChangePeer.Size()
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	if m.Split != nil {
		l = m.Split.Size()
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	if m.Transfer != nil {
		l = m.Transfer.Size()
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	if m.Compact != nil {
		l = m.Compact.Size()
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	return n
}

func (m *AdminResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovRaftcmdpb(uint64(m.Type))
	}
	if m.ChangePeer != nil {
		l = m.ChangePeer.Size()
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	if m.Split != nil {
		l = m.Split.Size()
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	if m.Transfer != nil {
		l = m.Transfer.Size()
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	if m.Compact != nil {
		l = m.Compact.Size()
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	return n
}

func (m *ChangePeerRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChangeType != 0 {
		n += 1 + sovRaftcmdpb(uint64(m.ChangeType))
	}
	l = m.Peer.Size()
	n += 1 + l + sovRaftcmdpb(uint64(l))
	return n
}

func (m *ChangePeerResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Shard.Size()
	n += 1 + l + sovRaftcmdpb(uint64(l))
	return n
}

func (m *SplitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SplitKey)
	if l > 0 {
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	if m.NewShardID != 0 {
		n += 1 + sovRaftcmdpb(uint64(m.NewShardID))
	}
	if len(m.NewPeerIDs) > 0 {
		l = 0
		for _, e := range m.NewPeerIDs {
			l += sovRaftcmdpb(uint64(e))
		}
		n += 1 + sovRaftcmdpb(uint64(l)) + l
	}
	if m.RightDerive {
		n += 2
	}
	return n
}

func (m *SplitResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Left.Size()
	n += 1 + l + sovRaftcmdpb(uint64(l))
	l = m.Right.Size()
	n += 1 + l + sovRaftcmdpb(uint64(l))
	return n
}

func (m *TransferLeaderRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Peer.Size()
	n += 1 + l + sovRaftcmdpb(uint64(l))
	return n
}

func (m *TransferLeaderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *CompactRaftLogRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CompactIndex != 0 {
		n += 1 + sovRaftcmdpb(uint64(m.CompactIndex))
	}
	if m.CompactTerm != 0 {
		n += 1 + sovRaftcmdpb(uint64(m.CompactTerm))
	}
	return n
}

func (m *CompactRaftLogResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	if m.Group != 0 {
		n += 1 + sovRaftcmdpb(uint64(m.Group))
	}
	if m.Type != 0 {
		n += 1 + sovRaftcmdpb(uint64(m.Type))
	}
	if m.CustemType != 0 {
		n += 1 + sovRaftcmdpb(uint64(m.CustemType))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	l = len(m.Cmd)
	if l > 0 {
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	if m.SID != 0 {
		n += 1 + sovRaftcmdpb(uint64(m.SID))
	}
	if m.PID != 0 {
		n += 1 + sovRaftcmdpb(uint64(m.PID))
	}
	if m.StopAt != 0 {
		n += 1 + sovRaftcmdpb(uint64(m.StopAt))
	}
	if m.ToShard != 0 {
		n += 1 + sovRaftcmdpb(uint64(m.ToShard))
	}
	if m.AllowFollower {
		n += 2
	}
	if m.LastBroadcast {
		n += 2
	}
	return n
}

func (m *Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovRaftcmdpb(uint64(m.Type))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	if m.OriginRequest != nil {
		l = m.OriginRequest.Size()
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	if m.SID != 0 {
		n += 1 + sovRaftcmdpb(uint64(m.SID))
	}
	if m.PID != 0 {
		n += 1 + sovRaftcmdpb(uint64(m.PID))
	}
	l = m.Error.Size()
	n += 1 + l + sovRaftcmdpb(uint64(l))
	if m.ContinueBroadcast {
		n += 2
	}
	if m.Stale {
		n += 2
	}
	return n
}

func sovRaftcmdpb(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozRaftcmdpb(x uint64) (n int) {
	return sovRaftcmdpb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RaftRequestHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftcmdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftRequestHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftRequestHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = append(m.ID[:0], dAtA[iNdEx:postIndex]...)
			if m.ID == nil {
				m.ID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardID", wireType)
			}
			m.ShardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardEpoch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ShardEpoch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaftcmdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftResponseHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftcmdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftResponseHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftResponseHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = append(m.ID[:0], dAtA[iNdEx:postIndex]...)
			if m.ID == nil {
				m.ID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentTerm", wireType)
			}
			m.CurrentTerm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentTerm |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaftcmdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftCMDRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftcmdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftCMDRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftCMDRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RaftRequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requests = append(m.Requests, &Request{})
			if err := m.Requests[len(m.Requests)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdminRequest == nil {
				m.AdminRequest = &AdminRequest{}
			}
			if err := m.AdminRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaftcmdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftCMDResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftcmdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftCMDResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftCMDResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RaftResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Responses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Responses = append(m.Responses, &Response{})
			if err := m.Responses[len(m.Responses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdminResponse == nil {
				m.AdminResponse = &AdminResponse{}
			}
			if err := m.AdminResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaftcmdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdminRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftcmdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdminRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdminRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdType", wireType)
			}
			m.CmdType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdType |= AdminCmdType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangePeer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChangePeer == nil {
				m.ChangePeer = &ChangePeerRequest{}
			}
			if err := m.ChangePeer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Split", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Split == nil {
				m.Split = &SplitRequest{}
			}
			if err := m.Split.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transfer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Transfer == nil {
				m.Transfer = &TransferLeaderRequest{}
			}
			if err := m.Transfer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compact", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Compact == nil {
				m.Compact = &CompactRaftLogRequest{}
			}
			if err := m.Compact.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaftcmdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdminResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftcmdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdminResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdminResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= AdminCmdType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangePeer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChangePeer == nil {
				m.ChangePeer = &ChangePeerResponse{}
			}
			if err := m.ChangePeer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Split", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Split == nil {
				m.Split = &SplitResponse{}
			}
			if err := m.Split.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transfer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Transfer == nil {
				m.Transfer = &TransferLeaderResponse{}
			}
			if err := m.Transfer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compact", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Compact == nil {
				m.Compact = &CompactRaftLogResponse{}
			}
			if err := m.Compact.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaftcmdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangePeerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftcmdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangePeerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangePeerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeType", wireType)
			}
			m.ChangeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangeType |= ChangePeerType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaftcmdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangePeerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftcmdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangePeerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangePeerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Shard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaftcmdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SplitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftcmdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SplitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SplitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SplitKey = append(m.SplitKey[:0], dAtA[iNdEx:postIndex]...)
			if m.SplitKey == nil {
				m.SplitKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewShardID", wireType)
			}
			m.NewShardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewShardID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRaftcmdpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NewPeerIDs = append(m.NewPeerIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRaftcmdpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRaftcmdpb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRaftcmdpb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NewPeerIDs) == 0 {
					m.NewPeerIDs = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRaftcmdpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NewPeerIDs = append(m.NewPeerIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NewPeerIDs", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightDerive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RightDerive = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRaftcmdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SplitResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftcmdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SplitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SplitResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Left", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Left.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Right", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Right.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaftcmdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransferLeaderRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftcmdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransferLeaderRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransferLeaderRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaftcmdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransferLeaderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftcmdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransferLeaderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransferLeaderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRaftcmdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompactRaftLogRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftcmdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompactRaftLogRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompactRaftLogRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactIndex", wireType)
			}
			m.CompactIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompactIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactTerm", wireType)
			}
			m.CompactTerm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompactTerm |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaftcmdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompactRaftLogResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftcmdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompactRaftLogResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompactRaftLogResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRaftcmdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftcmdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = append(m.ID[:0], dAtA[iNdEx:postIndex]...)
			if m.ID == nil {
				m.ID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			m.Group = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Group |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= CMDType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustemType", wireType)
			}
			m.CustemType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CustemType |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cmd = append(m.Cmd[:0], dAtA[iNdEx:postIndex]...)
			if m.Cmd == nil {
				m.Cmd = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SID", wireType)
			}
			m.SID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PID", wireType)
			}
			m.PID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StopAt", wireType)
			}
			m.StopAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StopAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToShard", wireType)
			}
			m.ToShard = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToShard |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowFollower", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowFollower = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastBroadcast", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LastBroadcast = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRaftcmdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftcmdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = append(m.ID[:0], dAtA[iNdEx:postIndex]...)
			if m.ID == nil {
				m.ID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= CMDType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OriginRequest == nil {
				m.OriginRequest = &Request{}
			}
			if err := m.OriginRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SID", wireType)
			}
			m.SID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PID", wireType)
			}
			m.PID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContinueBroadcast", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ContinueBroadcast = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stale", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Stale = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRaftcmdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRaftcmdpb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRaftcmdpb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRaftcmdpb
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupRaftcmdpb
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthRaftcmdpb
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthRaftcmdpb        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRaftcmdpb          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupRaftcmdpb = fmt.Errorf("proto: unexpected end of group")
)
